/*
 * @Author: Cao Haitao
 */

// 思路

// 根据会议的开始时间来安排会议有助于我们了解这些会议的自然顺序。然而，仅仅知道会议的开始时间，还不足以告诉我们会议的持续时间。我们还需要按照结束时间排序会议，因为一个“会议结束”事件告诉我们必然有对应的“会议开始”事件，更重要的是，“会议结束”事件可以告诉我们，一个之前被占用的会议室现在空闲了。

// 一个会议由其开始和结束时间定义。然而，在本算法中，我们需要 分别 处理开始时间和结束时间。这乍一听可能不太合理，毕竟开始和结束时间都是会议的一部分，如果我们将两个属性分离并分别处理，会议自身的身份就消失了。但是，这样做其实是可取的，因为：

// 当我们遇到“会议结束”事件时，意味着一些较早开始的会议已经结束。我们并不关心到底是哪个会议结束。我们所需要的只是 一些 会议结束,从而提供一个空房间。

// 分别将开始时间和结束时间存进两个数组。
// 分别对开始时间和结束时间进行排序。请注意，这将打乱开始时间和结束时间的原始对应关系。它们将被分别处理。
// 考虑两个指针：s_ptr 和 e_ptr ，分别代表开始指针和结束指针。开始指针遍历每个会议，结束指针帮助我们跟踪会议是否结束。
// 当考虑 s_ptr 指向的特定会议时，检查该开始时间是否大于 e_ptr 指向的会议。若如此，则说明 s_ptr 开始时，已经有会议结束。于是我们可以重用房间。否则，我们就需要开新房间。
// 若有会议结束，换而言之，start[s_ptr] >= end[e_ptr] ，则自增 e_ptr 。
// 重复这一过程，直到 s_ptr 处理完所有会议。


var minMeetingRooms = function(intervals) {
	let n=0;
	let left = 0;
	let right = 0;

	const start = [];

	const end = [];

	intervals.forEach(item=>{
		start.push(item[0]);
		end.push(item[1])
	})

	start.sort((a,b)=> a-b);

	end.sort((a,b)=> a-b);

	while(left < intervals.length){
		if(start[left] < end[right]){
			n++
		}else{
			right++
		}

		left++
	}

	return n
};



console.log(minMeetingRooms([[0,30],[5,10],[15,20]]))