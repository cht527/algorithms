/**
 * 
给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。

示例 1：

输入：nums = [10,2]
输出："210"
示例 2：

输入：nums = [3,30,34,5,9]
输出："9534330"
示例 3：

输入：nums = [1]
输出："1"
示例 4：

输入：nums = [10]
输出："10

---------------------------------------------------------------------------------------------
已知：s1应该在s2前边，s2应该在s3前边；
求证：s1应该在s3前边。

const s1=123,s2=99,s3=10;

const l1,l2,l3;


s1+s2>s2+s1 -> n1l2 + n2 > n2l1 + n1 -> n1(l2-1) > n2(l1-1);

s2+s3>s2+s3 -> n2l3 + n3 > n3l2 + n2 -> n2(l3-1) > n3(l2-1);


n1n2(l2-1)(l3-1) > n2n3(l1-1)(l2-1);

n1(l3-1) > n3(l1-1) -> n1l3 + n3 > n3l1 + n1 -> s1+s3 > s3+s1


证明：
假设“s3在s1前面”成立，则结合已知“s2应该在s3前边”，推出“s2在s1前面”，与已知“s1应该在s2前边”矛盾，故假设不成立，得证。


 */

function maxNum(arr){

    const num_ = arr.sort((a,b)=> `${b}${a}` - `${a}${b}`)

    return num_[0]===0 ? '0' : num_.join('')

}